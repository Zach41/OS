# Protection Mode

### 跳转保护模式

在IA32下，CPU有两种工作模式，保护模式和实模式。当我们打开PC的时候，CPU是工作在实模式下的，在经过某一种机制后，它才跳入了保护模式。在保护模式下，CPU具有巨大的寻址能力(32位下最大可寻址到4G)，并且为强大的32位操作提供了更好的硬件保障。

在实模式下，物理地址 = 段值　×　16 + 偏移，段值存储在cs，ds，es等寄存器中。而在保护模式下，依然有段式存储，但是原来的cs、ds、es等寄存的存储的不再是段基址，而是段选择子。选择子是一个索引，它指向一个数据结构的表项，表项中详细定义了段的起始地址、界限、属性等内容。这个数据结构就是GDT。GDT的每一个表项成为描述符。关于描述符的结构见书本P32。

在跳入保护模式之前，我们需要初始化GDT表，同时要填充gdt寄存器的值，gdt的结构为

|        32位基址        |    16位界限   |
| ---------------------- | ------------- |

然后打开A20地址线(由于历史问题，我们必须打开A20地址线，以便能够寻址到大于1MB的内存)。

```nasm
mov al, 92h
mov al, 00000010b
out 92h, al
```

然后将cr0寄存器的PE位(第0位)设置为1，PE = 0，CPU运行在实模式；PE = 1，CPU运行在保护模式。

最后跳转到32位的代码执行，那么此时，我们已经跳入到了保护模式了。

### Loader

当然我们并不能直接跳入保护模式，在这之前还有许多工作要做，如加载内核代码到内存当中。这里就有一个问题，如果全部的工作都放在了引导程序中完成，那么这个引导程序将会变得很庞大，512字节的容量非常有可能不够。为了解决这个问题，我们编写一个loader程序，引导程序负责将loader加载到内存中，后续的工作就全部由loader负责。如何加载程序到内核见书本P109。

Loader负责的工作:

- 设置GDT表
- 加载内核到内存
- 初始化
- 跳入保护模式
- 开启分页
- 将控制权交给内核

需要注意的是在开启分页机制之前，我们需要知道内存的大小以设置页目录项和页表的个数。如果不这样做，而是直接设置页目录为1024个，那么全部的页表就占了1024 * 1024 * 4k = 4MB，我们的虚拟机机内存只有32MB，很显然这会造成很大的浪费。怎么读取内存容量并正确设置分页见书本P73

### 内核文件

内核是一个ELF文件，ELF文件的结构如下所示：

| ELF Header       | 
| :--------------: |   
| Program header 0 | 
| Program header 1 | 
| ...              | 
| Section 0        |
| Section 1        |
| Section header 0 |
| Section Header 1 |
| ...              |

ELF Header的结构具体见书本P123，我们在程序用需要用到的列举如下：

- e_entry：程序的入口地址
- e_phoff：Program header table在文件中的偏移量
- e_phnum：Program header table有多少个条目
- e_phentsize：Program header table一个条目的大小

同样的，Program header的结构具体见书本P125，这里列出需要用到的：

- p_offset：段的第一个字节在文件中的偏移
- p_vaddr：段的第一个字节在内存中的虚拟地址
- p_filesz：段在文件中的长度
- p_memsz：段在内存中的长度

知道了以上信息之后，我们就可以在loader加载内核到内存后重新放置内核，以便让内核正确地执行。要注意的是，在链接内核文件的时候，我们不能让编译器指定内核应该加载到内存的什么地方，不然可能会超出内存地址空间。我们修改`ld`命令的选项来修改内核加载的地址。

```
ld -s -Ttext 0x30400 0 kernel.bin kernel.o
```

loader在把控制权交给内核之后，内核就可以开始初始化了。到这里有一个天大的好消息，可以用C开始写代码了，虽然还会在某些地方用汇编写，但是大部分的工作都可以用C来完成了。







