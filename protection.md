# Protection Mode

### 跳转保护模式

在IA32下，CPU有两种工作模式，保护模式和实模式。当我们打开PC的时候，CPU是工作在实模式下的，在经过某一种机制后，它才跳入了保护模式。在保护模式下，CPU具有巨大的寻址能力(32位下最大可寻址到4G)，并且为强大的32位操作提供了更好的硬件保障。

在实模式下，物理地址 = 段值　×　16 + 偏移，段值存储在cs，ds，es等寄存器中。而在保护模式下，依然有段式存储，但是原来的cs、ds、es等寄存的存储的不再是段基址，而是段选择子。选择子是一个索引，它指向一个数据结构的表项，表项中详细定义了段的起始地址、界限、属性等内容。这个数据结构就是GDT。GDT的每一个表项成为描述符。关于描述符的结构见书本P32。

在跳入保护模式之前，我们需要初始化GDT表，同时要填充gdt寄存器的值，gdt的结构为

-----------------------------------------
|        32位基址        |    16位界限   |
-----------------------------------------


然后打开A20地址线(由于历史问题，我们必须打开A20地址线，以便能够寻址到大于1MB的内存)。

```nasm
mov al, 92h
mov al, 00000010b
out 92h, al
```

然后将cr0寄存器的PE位(第0位)设置为1，PE = 0，CPU运行在实模式；PE = 1，CPU运行在保护模式。

最后跳转到32位的代码执行，那么此时，我们已经跳入到了保护模式了。

### Loader

当然我们并不能直接跳入保护模式，在这之前还有许多工作要做，如加载内核代码到内存当中。这里就有一个问题，如果全部的工作都放在了引导程序中完成，那么这个引导程序将会变得很庞大，512字节的容量非常有可能不够。为了解决这个问题，我们编写一个loader程序，引导程序负责将loader加载到内存中，后续的工作就全部由loader负责。如何加载程序到内核见书本P109。

Loader负责的工作:

- 设置GDT表
- 加载内核到内存
- 初始化
- 跳入保护模式
- 开启分页
- 将控制权交给内核

需要注意的是在开启分页机制之前，我们需要知道内存的大小以设置页目录项和页表的个数。如果不这样做，而是直接设置页目录为1024个，那么全部的页表就占了1024 * 1024 * 4k = 4MB，我们的虚拟机机内存只有32MB，很显然这会造成很大的浪费。怎么读取内存容量并正确设置分页见书本P73

### 内核文件

内核是一个ELF文件，ELF文件的结构如下所示：

 --------------------------
|        ELF header        |
----------------------------
|    Program header 0      |
----------------------------
|    Program header 1      |
----------------------------
|          ...             |
----------------------------
|        section 0         |
----------------------------
|        section 1         |
----------------------------
|          ...             | 
----------------------------
|    section header 0      |
----------------------------
|    section header 1      |
----------------------------
|          ...             |
----------------------------





